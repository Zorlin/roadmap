Types:
        1: A Block has the following fields:
        parent 
	hash
        view
        qc
        aggQC
        signature
        transactions
        randomseed  #Provides the proof for being the leader of the round. This field may not be needed if the qc is used to generate the random seed.
        
        
        
        2: A vote has the following fields:
        block hash
        view 
        signer
        signature
	qc #
        
        
        3: A QC has the following fields:
        block       # Hash of a block is used in this field as a representative of the actual block.
        view
        signers
        signature
        Type # Better to have two different types of QCs
        

        4: An aggQC has the following fields:
        qcs
	highQC # latest qc in qcs
        view
        signers
        signature
	
	5: A newView message has the followiing fields:
	view
	highQC
	signer
	signature


Local Variables:
        highQC
	#qc_c # QC built from messages received from child committees
        curView
        latestCommittedBlock


#####Supermajority of child votes is 2/3 +1 votes from members of child committees
#####Supermajority for the qc to be included in the block, should have at least 2/3+1 votes from both children of the root committee and overal 2/3 +1
#####combined votes of the root committee+its child committees.

Utilities:
     leader (view): returns the leader of the view.
     reset(): resets timer. If the timer expires a node times out.
     extends(block, ancestor): returns true if block is descendant of the ancestor in the chain.
     download(view): Download missing block for the view.
     getMaxViewQC(qcs): returns the qc with the highest view number.
     memberOfLeafCommittee(): returns true if a node is in the leaf committee of the committee overlay
     memberOfInternalComExceptRoot(): returns true if a node is member of internal committees within the committee tree overlay except root committee
     memberOfInternalCom(): returns truee if a node is member of internal committees within the committee tree overlay
     childcommittee (signer): returns true if the node id (signer) in the nodeIndx is member of the child committee 
     supermajority(votes): returns if the number of distinctive signers of votes for a block is is equal to the threshold or returns if the qourum size has reached.
     morethanSsupermajority(votes): returns if the number of distinctive signers of votes for a block is is more than the threshold

#Core Functions of the Carnot consensus:

        Func safeBlock(block){
		 # this check makes sure block is not old and the previous leader did not fail
	        if block.qc != Null{
		        return block.view >= curView and block.view == block.qc.block.view + 1
                }
		# this means previous leader/leaders have failed. But still we need to check if the block is not old and the block extends from a valid ancestor.
	        if block.aggQC != Null{ 
		        return block.view >= curView and extends(block, block.aggQC.highQC.block)

                }
        }
	
	# Commit a grand parent if the grandparent and the parent have been added during two consecutive views.
	Func tryToCommitGrandParent(block){ 
	          parentBlock = block.qc.block
		  grandparentBlock = parentBlock.qc.block
		  return parentBlock.view = grandparentBlock.view+1
		  #update latest committed block

	}

	#Update the latest certification (qc) and view number 
        Func update_higQC(qc, aggQC){
		# Happy case
		if qc != Null{ 
			if qc.block.view > highQC.block.view{
				highQC = qc
				}
			if qc.block.view > curView { 	# download blocks from missing views
				while curView++ <= qc.block.view {
				download(curView) 
				reset()
				}
			}
		}

		 # Unhappy case
		if aggQC != Null {
			if aggQC.highQC.block.view != highQC.block.view{
				highQC = aggQC.highQC # release the lock and adopt the global lock 
				if aggQC.highQC.block.view > curView { # download the blocks of the missed views
					while curView++ <=  aggQC.highQC.view {
						download(curView) 
						reset()
					}
				}
   
        		}
	}
        
	
	
	
        Func receive(block){
		if block.hash is known OR block.view <= latestCommittedBlock.view {return}
		if block.parent missing{ download(block.parent)}
		#Previous leader did not fail and its proposal was certified
		if block.qc != Null 
			{if block.qc.block.view <= latestCommittedBlock.view {return}}
	
		# Previous leader failed
		if block.aggQC! = Null
			{ 
			block.aggQC.highQC = getMaxViewQC (block.aggQC.qcs)
			# Since verification of signatures  is not included in this psuedocode, it is worth mentioning that here verification of block.aggQC.highQC
			# along with the block.aggQC.signature is suffice. No need to verify each qc inside block.aggQC
			if block.aggQC.highQC.view <= latestCommittedBlock.view {return}
			#if block.aggQC.view < curView
			}
		
		if safeBlock(block){
			update_higQC(block.qc, block.aggQC)
			if memberOfLeafCommittee(){ send(vote, parentCommittee)
			curView++
			reset()
			tryToCommitGrandParent(block)
			}
			if onlyOneCommittee(){
				send(vote, leader(view+1))
				curView++
				reset()
				tryToCommitGrandParent(block)
			}
		
		}
		
	}
	
	
	Func receive(vote){ 
		if vote.block missing {download(vote.block)}
		#Make sure block is verified before voting
		if vote.block.view < curView - 1{ return}
		if memberOfInternalComExceptRoot(nodeIndx) {
			if childcommittee (vote.signer) { collection[vote.block].append(vote)}
			if supermajority(collection[vote.block]){
			send(vote, parentCommittee)
			curView++
			reset()
			tryToCommitGrandParent(block)
			}
		
		}
		if memberofRootCommittee(nodeIndx){
			if childcommittee(vote.signer) { collection[vote.block].append(vote)}
			if supermajority(collection[vote.block]){
			qc=buildQC(collection[vote.block])
			vote.qc=qc
			send(vote, leader(curView+1))
			curView++
			reset()
			tryToCommitGrandParent(block)
			}
			if morethanSsupermajority(collection[vote.block]){send(vote, leader(curView+1))}
		
		}
		
	
		
		if nodeIndx==leader(view){
			collection[vote.block].append(vote)
			if supermajority(collection[vote.block]){
			qc=buildQC(collection[vote.block])
			block=buildBlock()
			Broadcast(block)
			}
		
		}
		
	
	}
	
	
	# Failure Case
	Func receive (newView){
		if newview.highQC.block missing {download(new_view.high_qc.block)} # download the missing block 
		adjust_high_qc_and_view(new_view.high_qc, Null)
		if newView.view < curView: return # It's an old message. Ignore it.
		if memberOfInternalCom(nodeIndx){
		collection[newView.view].append(newView)
		if supermajority[newView.view]{
			newViewQC=buildQC(collection[newView.view])
			if memberofRootCommittee(nodeIndx){
				send(newViewQC, leader(view+1))
				curView++
			}
			send(newViewQC, parentCommittee)
			}
		}
		

	
	}
	
	Func timeout(){}
        
